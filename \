---
theme: seriph
title: The Ultimate Guide to Building Web Components with Svelte
info: |
  Slides for the talk "The Ultimate Guide to Building Web Components with Svelte" held at Svelte Summit 2025 in Barcelona by Theo Steiner.
class: text-center
drawings:
  persist: false
transition: slide-left
mdc: true
---

# The Ultimate Guide to Building Web Components with Svelte

Theo Steiner

<!--
Hey everyone, welcome to "The Ultimate Guide to Building Web Components with Svelte".
If you've ever been nervous about speaking in front of people, try putting 'ultimate guide' in name of your talk.
Really ups the game a bit.
But before you watch me crash and burn trying to live up to that title,
Let's get a bit meta for a second and talk about why you would even want to build web components in the first place.
-->

---

```yaml
layout: two-cols
```

<div style="background-image: url(/assets/harris_richard.png);" class="relative h-full bg-contain bg-no-repeat">
  <div 
    style="background-image: url(/assets/harris_lizard.png);"
    class="absolute inset-0 bg-contain bg-no-repeat opacity-0 transition-opacity" 
    :class="{
      'opacity-50': $clicks === 2,
      'opacity-100': $clicks >= 3
    }"
  />
  <div 
    v-click="4"
    style="background-image: url(/assets/harris_lizard_conspiracy.png);"
    class="absolute inset-0  bg-contain bg-no-repeat" 
  />
</div>

::right::

<div class="relative h-full w-full">
<div v-click="1" style="background-image: url(/assets/rich_harris_why_i_dont_use_webcomponents.png);" class="bg-contain bg-no-repeat bg-center absolute inset-0"/>
<div class="absolute inset-0 transform rotate-6 scale-75">
  <Tweet v-click="2" id="1839484645194277111"/>
</div>
<div class="absolute inset-0 transform -rotate-6">
  <Tweet v-click="3" id="1844134732306792631"/>
</div>
</div>

<!--
Since most of you folks are probably devote disciples of his,
I thought we could maybe get Svelte Jesus, ugh I mean, Rich Harris to tell you why you should use web components.
But, since I'm terrified of unscripted live interaction, instead of asking the real Rich in the audience, I did what any sane person would do and went on twitter to find his endorsements.

Let's see, what do we have here..?
[click] "WHY I DON'T USE WEB COMPONENTS"... uhm okay, maybe rich wasn't as pro-platform as I thought..
[click] "If I could bill someone for the time I've spent working __around__ web components in svelte, I'd be a rich man"
...Now that's a bit negative, don't you think?
[click] "the right answer is 'don't use web components and you'll never have to think about this madness'"
Damn... that's devastating.
[click] But, of course Rich would say something like that.
I mean look at his lizardy face!
He __is__ one of them. Big JavaScript. THEY want you to send bloated bundles to your users so they can feed on your bandwidth!
Web Components surely are the future, I mean, "USE THE PLATFORM!", right?!
So let's maybe consult somebody more trustworthy to get our facts right..
You know, somebody who has no reason to hide the truth from you in order to farm orange github stars.
Like, let's say, someone who gives a talk on web components.
Like, you know, me!
-->

---

```yaml
layout: two-cols
```

<div style="background-image: url(/assets/theo_steiner.webp);" class="relative h-full bg-cover bg-no-repeat bg-center mx-1.5rem"/>

::right::

<div class="relative h-full w-full">

<v-clicks>

- Theo Steiner (テオ)
  - <ri-bluesky-fill/> @theosteiner.de
- Software Engineer at LY Corporation in Tokyo
  - <ri-line-fill/> working on `LINE Messenger`
- Certified Svelte Stan
  - <ri-svelte-fill/> Svelte Ambassador & Member of Svelte Japan
- Working with Web Components
  - <ion-logo-web-component/> Using Svelte-built WCs in Production
- Not a reptiloid
  - <ion-logo-python/> use the platform!

</v-clicks>

<div class="absolute inset-0 transform -rotate-6">
  <Tweet v-click="6" id="1833417673251946987"/>
</div>
<div v-click="7" style="background-image: url(/assets/theo_whats_in_the_box.png);" class="bg-contain bg-no-repeat bg-center absolute inset-0"/>
<div v-click="8" style="background-image: url(/assets/theo_components_at_home.png);" class="bg-contain bg-no-repeat bg-center absolute inset-0 transform rotate-6"/>
</div>

<!--
So, who am I, you ask?
[click] My name is Theo Steiner and I'm a software engineer at LY Corporation in Tokyo.
[click] For my dayjob, I get to work on LINE, which is the most popular messenger app in Japan with over 150 million monthly active users.
[click] I'm also a "svelte ambassador", which basically means I'm a certified svelte stan, and have been for years.
Svelte was actually my introduction to frontend development and I owe a lot to the framework and the awesome people behind it.
To give back to the community, I help organize meetups in Japan, so if you're ever in the area, feel free to reach out.
[click] And of course, I work with web components on a daily basis, hence this talk.
[click] Also, and I can't believe I have to say this, but I'm totally not JavaScript loving reptile in disguise, I promise!

So now that you know that my opinion on web components can be trusted, let's look through my tweets to try undo the damage Rich's statements have done to web components.

[click] "pretending web components have solved frontend is just so disingenuous. 🌶️ there are just so many rough edges, I think it is literally impossible to build anything substantial without having to cut at least some corners"
Wait... what? That one must have snuck in there by accident, I thought we wanted to be positive here.
[click] "building accessible web components is the kind of task that makes maintaining cobol mainframes look like a dream job"
this is getting worse by the minute.
[click] Okay, I give up, Big JavaScript won, web components are not a silver bullet.
It's true, in most cases you probably shouldn't use them & stick to a modern frontend framework... like svelte!
But while they might not the future for all of Web Development, they do have some properties that make them a invaluable for certain, specific use cases.
-->

---

```yaml
layout: two-cols-header
class: grid-rows-2
```

# What are web components?

::left::

<v-clicks class="min-h-full">

- A set of Plattform Standards for building UI Components
  - Custom Elements
  - The `<template>` & `<slot>` elements
  - Shadow Dom
- Basically let's you declare a new html element & compose it in your dom however you like
- Encapsulation
  - Web Components are frameowrk agnostic

</v-clicks>

::right::

<div v-click="2" class="px-4">
```html {3-5}
<html>
  <h1>hello world</h1>
  <my-element>
    <p>nested content</p>
  </my-element>
</html>
```
</div>

::bottom::

<!--
An ultimate guide to building web components would not be complete, without giving a primer about what `web components` even are.
[click] The name "Web components" actually is an umbrella term for a collection of APIs, that allow us to build Components, that is,  a reusable piece of UI,
using native browser features.
While we are normally confined to using only html elements browsers provide, custom elements allow us to extend the html with elements we can implement ourselves.
These custom elements are implemented as classes that extend a base `HTMLElement` class and are notified about their state in the DOM via lifecycle methods.
In order to compose with native html elements, they can define "holes" in their markup by using the `<slot>` element.
If you have used svelte before version 5, you might be familiar with slots as a way to nest content within a component.
The last API that is part of the web components standard is this thing called the "shadow dom" - a technology for attaching isolated DOM trees to our document.
Simply put, it allows us to encapsulate our component's markup and styles, so that they are not affected by the outside world and vice versa.
[click] This encapsulation is precisely what makes web components worth using.
While they might not be the best choice to base your stack on in a vacuum, in practice, things are messy & we don't always get to work with nice unified tech stacks.
We might have varying tech stacks across products, or even ship our code to third parties where we don't know what technology they are using.
In my opinion, this is the use case where web components shine the most.
Not like the name suggests, as "components" that help you organize individual pieces of codes,
but rather as encapsulation tools that let you distribute your code without having to worry about compatibility.
For example at LINE, we use custom elements to share reusable components between different products.
That way, even if the frameworks or framework version differ across products, we still can share an implementation.
Another use case that comes to mind is distributing small self-contained units of code.
Like, for example, a checkout widget that you can just drop onto your website to handle payments.
-->

---

```yaml
layout: two-cols
class: max-h-full overflow-auto
```

<style>
* {
  scrollbar-width: none;
}
</style>

<div class="relative h-full max-w-full mx-1.5rem overflow-hidden">
<div v-click.hide="1" class="absolute inset-0 flex flex-col gap-2">

<<< @/components/WcCounter.vue vue

<WcCounter/>

</div>

<div v-click="1" style="background-image: url(/assets/web_component_lifecycle.png);" class="absolute inset-0 bg-contain bg-no-repeat"/>
</div>

::right::

<div class="max-h-full overflow-auto" style="scrollbar-width: none;">
<<< @/snippets/my-counter.js {1-26|1|42-44|2-14|15-31|32-36|37-39}{maxHeight: '100%'}

</div>

<!--
Now let's quickly go over how custom elements are built using vanilla javascript.
While the example looks a bit verbose, it is actually just a very simple counter component, where the value the counter is incremented by can be set via an attribute.
In this example, we subclass `HTMLElement` to create our own `MyCounter` custom element class.
[click] To register the custom element we call customElements.define() passing in a tag name and the class we defined above.
Once registered, we can use our custom element in the DOM like any other html element.
This means, we can instantiate the 'my-counter' element using the `document.createElement()` API.
[click] Upon creation, the element's constructor is called and properties are initialized.
To render our element, we need to attach it to the DOM, for example by appending it to the document body.
[click] This is where the `connectedCallback` lifecycle method is called, telling us that our element is now part of the DOM.
In the example, we create a button element and append it to the shadow root of our custom element.
We also setup an event listener for the button's click event.
You can sort of think of the `connectedCallback` as the equivalent of a svelte component's `onMount` lifecycle method.
Except that since svelte doesn't render for us, we have to manually insert and update our content in the DOM by calling the `render()` method.
[click] While our component is connected to the DOM, we are notified about changes to the attributes of our element via the `attributeChangedCallback`.
Please note, that since html attributes are always strings, we need to convert the attribute value to a number before storing it in our component's increments property.
Since we don't have reactivity in vanilla JavaScript we need to manually call `render()` to reflect the changed state in the UI.
[click] Finally, we have the `disconnectedCallback` lifecycle method, which is called when our element is removed from the DOM.
This is where we can clean up side effects we caused during our component's lifetime, such as adding event listeners or rendering to the dom.
-->

---

```yaml
layout: two-cols-header
```

# Building Web Components with Svelte

::left::

<div class="mx-1.5rem flex flex-col gap-2">

<<< @/snippets/MyCounter.svelte svelte

<v-clicks at="1">

<<< @/svelte.config.js js

</v-clicks>

<v-clicks at="2">

<<< @/snippets/my-svelte-counter.js js

</v-clicks>

</div>

::right::

<v-clicks>

- Custom Element via Compiler Setting
  - `customElement: true`
- `Component.element` property contains constructor
  - can be used to register custom element
- But it does not yet work quite like expected...
  - <SvelteWcCounter/>

</v-clicks>

<!--
As you just saw, building web components using vanilla JavaScript quickly turns your code into imperative spaghetti rather quickly.
I don't have to tell you that svelte allows us to write the same functionality in way less, declarative code.
But how do we turn this svelte component into a custom element?
[click] Literally all we have to do for this to work is adding `customElement: true` to the compiler settings in our svelte config.
If we build our project now, an `element` property is newly added to the default export of our compiled svelte component.
[click] This property contains the constructor for a custom element version of our component.
We can now pass this constructor alongside a tag name to `customElements.define()` to register the component with the window's custom element registry.
Once we've registered it, all that's left to do is using our tag name to reference the element within our html
[click] & voila, our svelte built web component is ready to be used within any context,
be it vanilla JS or another framework like react or vue.
In fact, the slides you are looking at right now are built using vite, and we are seemlessly using a svelte component within them.
However, there is one issue with the code we just wrote... let's try actually incrementing...
Ooops, I'm not entirely sure, but I don't think this is how a counter is supposed to work...
-->

---

```yaml
layout: two-cols-header
```

# Building Web Components with Svelte

::left::

<div class="mx-1.5rem">

<!-- prettier-ignore-start -->

````md magic-move
<<< @/snippets/MyCounter.svelte svelte

<<< @/snippets/Props.svelte svelte

<<< @/snippets/Options.svelte svelte

<<< @/snippets/Host.svelte svelte
````

<!-- prettier-ignore-end -->

</div>

::right::

<v-clicks at="1">

- custom element `<svelte:options>`
  - name (`customElements.define`)
  - props
  - extends
- `$host()` rune
  - retrieves host element inside CE
  - used to dispatch events

</v-clicks>

<!--
So, we're not adding the numbers, but seem to be concatenating them instead.
This is because we pass the `increments` prop via an attribute to the custom element.
Svelte has no way of knowing which types we want our props to be, so we have to give it a hint.
[click] We can do this by using the `customElement` attribute of the `svelte:options` element.
Here we can pass a configuration object, that has a 'props' property, that allows us to specify what type conversion we want to run for each prop.
While props are camelCased in svelte, HTML attributes are case insensitive and therefore usually written in kebab-case.
The `props` setting also allows us to accomodate for this by via the `attribute` property.
[click] There is a whole range of other settings we can pass here, but I don't find myself using them very often.
The `tag` property allows us to skip manually defining the custom element, with the compiler taking care of it for us.
However, since registering the same custom element multiple times will throw an error, I prefer doing this manually checking for existing registrations beforehand.
You can also use the `shadow` property to opt out of using the shadow dom.
Finally, if you really need fine grained control over the custom element, you can use the `extends` property to modify the base class of the custom element.
TODO: explain that our initial svelte component did not convert it's stepSize prop from a `step-size` attribute to a number & therefore has a bug.
TODO: explain other settings possible using svelte:options (name, extends, shadowrootmode)
TODO: explain `$host` rune
-->

---

```yaml
layout: image-left
image: /assets/svelte_web_component_lifecycle.png
backgroundSize: 50%
```

# Anatomy of a Svelte-built Web Component

- Empty `shell` web component
- Svelte component mounted in wrapper's shadow DOM
  - svelte component is just a regular svelte component
- mount/unmount of inner component delayed by one microtask
- convert attributes to props

<!--
So how is our svelte component turned into a web component?
You might think that svelte as a compiler could generate something along the lines of the vanilla web component we wrote earlier.
And in fact, up until Svelte 4 it actually used to do something just like that.
But today, svelte employs more of an matrioshka approach to generating web components.
On the outside, we have a barebones custom element.
And then, on the inside, we have a regular svelte component.
I think this becomes a bit clearer when we look at the lifecycle of a svelte-built web component.

TODO: The outside layer is responsible for mounting and unmounting the inner component, as well as converting attributes to props.

TODO: explain lifecycle & svelte component wrapped by an empty web component shell responsible for mounting & unmounting, as well as converting attributes to props.
-->

---

# Issues When Building Web Components with Svelte

- getting started (can't use sveltekit)
- configuration (kebab-case, statically analyzable svelte:options)
- currently no way to SSR

---
